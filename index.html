<!DOCTYPE html>  
<html>
<head>
    <meta charset="utf-8" />
    <title>Samourai Whirlpool live</title>
	
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="js/vivagraph.js"></script>  
    <script type="text/javascript" src="js/webgl-programs.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
    <style>
    body{
        margin: 0;
        padding: 0;
        position: relative;
        background:#054050;
        color:#cbd7da;
    }
    .input-node{color:green;}
    .output-node{color:red;}
    .input-output-node{color:orange;}
    .transaction-node{color:#008ed2;}

    #log{
        position: absolute;
        left:4px;
        top:4px;
        padding:4px;
        text-align:left;
        font-size:0.8em;
    }
    #info{
        position: absolute;
        right:4px;
        top:4px;
        padding:4px;
    }
    </style>

    <link rel="shortcut icon" href="http://samouraiwallet.com/static/public/favicon/favicon.ico"/>
    <link rel="apple-touch-icon" sizes="57x57" href="http://samouraiwallet.com/static/public/favicon/apple-icon-57x57.png"/>
    <link rel="apple-touch-icon" sizes="60x60" href="http://samouraiwallet.com/static/public/favicon/apple-icon-60x60.png"/>
    <link rel="apple-touch-icon" sizes="72x72" href="http://samouraiwallet.com/static/public/favicon/apple-icon-72x72.png"/>
    <link rel="apple-touch-icon" sizes="76x76" href="http://samouraiwallet.com/static/public/favicon/apple-icon-76x76.png"/>
    <link rel="apple-touch-icon" sizes="114x114" href="http://samouraiwallet.com/static/public/favicon/apple-icon-114x114.png"/>
    <link rel="apple-touch-icon" sizes="120x120" href="http://samouraiwallet.com/static/public/favicon/apple-icon-120x120.png"/>
    <link rel="apple-touch-icon" sizes="144x144" href="http://samouraiwallet.com/static/public/favicon/apple-icon-144x144.png"/>
    <link rel="apple-touch-icon" sizes="152x152" href="http://samouraiwallet.com/static/public/favicon/apple-icon-152x152.png"/>
    <link rel="apple-touch-icon" sizes="180x180" href="http://samouraiwallet.com/static/public/favicon/apple-icon-180x180.png"/>
    <link rel="icon" type="image/png" sizes="192x192" href="http://samouraiwallet.com/static/public/favicon/android-icon-192x192.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="http://samouraiwallet.com/static/public/favicon/favicon-16x16.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="http://samouraiwallet.com/static/public/favicon/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="96x96" href="http://samouraiwallet.com/static/public/favicon/favicon-96x96.png"/>
</head>
<body>
	<div id="g" style="background:#043a48; border-bottom:12px solid #c12727; width:100%; height:800px;"></div>
    <div id="info"></div>
    <div id="log">
        Processed <span id="blocks">0</span> blocks since #<span id="blockHeight">0</span>, <span id="allTxs">0</span> txs.<br/>
        <small id="txHash"></small>
    </div>
    <div style="float:right">&lt;scroll&gt; to zoom<br/>&lt;space&gt; to pause</div>
    <center>
        <h1>Samourai Whirlpool live</h1>
        Visualizing Whirlpool transactions from 100 last blocks and mempool (real-time).<br/>

        <span class="input-node">Green = input</span>, <span class="output-node">Red = unspent output</span>,
        <span class="input-output-node">Yellow = spent output</span><br/>

        <span class="transaction-node"><span id="whirlpoolTxs">0</span> mixs</span>,
        <!--<span style="color:#29efef"><span id="tx0s">0</span> tx0s</span>, --><span style="color:#ff7100"><span id="spends">0</span> postmix spends</span>
    </center>

    <br/><br/>
    <center><small style="color:#ccc"><a href="https://samouraiwallet.com">SamouraiWallet</a> - Visualization forked from <a href="https://dailyblockchain.github.io/" target="_blank">dailyblockchain.github.io</a></small></center>

</body>
    <script language="javascript" type="text/javascript">  
    // viva graph part 
    var graphics = Viva.Graph.View.webglGraphics();
    
    var isWebgl = graphics.isSupported();
    if (!isWebgl) {
        alert("Turn on webgl or use modern browser");
    }
    
    var graph = Viva.Graph.graph(),
    layout = Viva.Graph.Layout.forceDirected(graph, {
       springLength : 80,
       springCoeff : 0.0002,
       dragCoeff : 0.009,
       gravity : -30,
       theta : 0.7
    }), 

	minNodeSize = 1,
    maxNodeSize = 100000000;

    function getPoolColor(pool) {
        return 0x008ED2;
        /*if (pool) {
            switch (pool) {
                case "0.5btc": return 0xeb3030;
                case "0.05btc": return 0x410d0d;
                case "0.01btc": return 0x6c1616;
                case "0.001btc": return 0x961e1e;
            }
        }
        console.error('unknown pool:',pool)
        return "#000000";*/
    }

    function getPoolSize(pool) {
        if (pool) {
            switch (pool) {
                case "0.5btc": return 500;
                case "0.05btc": return 50;
                case "0.01btc": return 10;
                case "0.001btc": return 1;
            }
        }
        console.error('unknown pool:',pool)
        return 1;
    }

    function log10(val) {
        return Math.log(val) / Math.LN10;
    }

    function log2(val) {
        return Math.log(val) / Math.LN2;
    }

    var scaleType = "LOG";//"LINEAR"; //"LOG"; // LINEAR

    var getNodeColor = function(node) {
        // here different colors for tx, input, output, mixed and txconfirmed
        if(node.data && node.data.t && node.data.t == "i"){ 
            return 0x00FF00;
        }else if(node.data && node.data.t && node.data.t == "o"){
            return 0xFF0000;
        }else if(node.data && node.data.t && node.data.t == "m"){
            return 0xFFA500;
        }

        if (node.data.tt == TXTYPE.SPEND) {
            return 0xff7100;
        } else if (node.data.tt == TXTYPE.TX0) {
            return 0x29efef;
        }
        return 0x008ED2; //getPoolColor(node.data.p); //0x008ED2
    },

    getLinkColor = function(link) {
        if (link.data.tt == TXTYPE.SPEND) {
            return 0xFF0000;
        } else if (link.data.tt == TXTYPE.TX0) {
            return 0x00FF00;
        }
        return 0x808080; //getPoolColor(node.data.p); //0x008ED2
    },
    
    getNodeSize = function(node){
        var value
        if(!node.data.s){
            // tx
            value = node.data.tv;
            //console.log('size tx',value)
        } else {
            // outpoint
            value = node.data.s;
            //console.log('size outpoint',value)
        }

        value = value*value*value

        //value = node.data.s/100000;
        //value = value*value;

        var rmin = 1;
        var rmax = 25;
        

        // linear normalization to a range rmin,rmax
        if(scaleType == "LINEAR"){
            return rmin + (rmax - rmin) * ( (value - minNodeSize)/(maxNodeSize - minNodeSize) ) ;
        }else{    
            // log normalization to a range rmin,rmax
            var min = log2(minNodeSize);
            var max = log2(maxNodeSize);
            var val = log2( value );

            // linear scaling from min.max -> rmin rmax
            return rmin + (rmax - rmin) * ( (val - min)/(max - min) ) ;
        }
    },
    getNodeDetails = function(node){
        console.log('details',node);
        var label = "transaction";
        var id = '';
        if(node.data && node.data.t){
            // input/output
            id += 'Address: <a href="https://oxt.me/address/' + node.id + '" target="_blank">' + node.id + '</a><br/>';
            if(node.data.t == "i"){
                // input node
                label = "input";
            }else if(node.data.t == "o"){
                // output node
                label = "unspent output";
            }else if(node.data.t == "mix"){
                // node which is both input and output
                label = "spent output";
            }

        }else{
            // transaction node
            id='';
        }
        var linkData = node.data ? node.data : node.links[0].data
        id += 'Tx: <small><a href="https://oxt.me/transaction/' + linkData.h + '" target="_blank">' + linkData.h + '</a></small><br/>';
        id += 'Pool: '+linkData.p;
        var html = "<h4>"+linkData.tt+' '+label+"</h4><small>"+id
        if (node.data.s) {
            html += "<br/>Value: "+(node.data.s/100000000)+" BTC";
        } else {
            html += "<br/>Volume: "+(node.data.tv/100000000)+" BTC";
        }
        document.getElementById("info").innerHTML = html
    };

    // need to get these 2 from yavis.reddit.min.js
    graphics.setLinkProgram(Viva.Graph.View.webglDualColorLinkProgram());
    graphics.setNodeProgram(Viva.Graph.View.webglCustomNodeProgram());

    graphics
    .node(function(node){
        return Viva.Graph.View.webglSquare(getNodeSize(node), getNodeColor(node));
        /*if (false && node.data) {
            return Viva.Graph.svg('image')
                .attr('width', 24)
                .attr('height', 24)
                .link(node.data.url);

        } else {
            return Viva.Graph.View.webglSquare(getNodeSize(node), getNodeColor(node));
        }*/
     })
    .link(function(link){
         var fromColor, toColor;
         fromColor = toColor = getLinkColor(link);//0x808080;//getPoolColor(link.data.p)
         var line = Viva.Graph.View.webglDualColorLine(fromColor, toColor);
         line.oldStart = fromColor;
         line.oldEnd = toColor;
         return line;
    });

    var renderer = Viva.Graph.View.renderer(graph,{
       layout     : layout,
       graphics   : graphics,
       container  : document.getElementById('g')
       //prerender  : 10
    });

    var blocks = 0, blockHeight='', allTxs = 0, whirlpoolTxs = 0, spends = 0, tx0s = 0, since=new Date().toISOString();

    var events = Viva.Graph.webglInputEvents(graphics, graph),
    lastHovered = null,

    colorLinks = function(node, color) {
     if (node && node.id) {
        graph.forEachLinkedNode(node.id, function(node, link){
            if (color) { 
                link.ui.start = link.ui.end = color;
            } else {
                //link.ui.start = link.ui.oldStart; 
                //link.ui.end =link.ui.oldEnd;
                link.ui.start = link.ui.end = 0x80808040;
            } 
        });
     }
    };
                 
    events.click(function(node){
        
	    getNodeDetails(node);

        colorLinks(lastHovered);
        lastHovered = node;
     
        graph.forEachLinkedNode(node.id, function(node, link){
            link.ui.start = link.ui.end = 0xffffffff;
            graphics.bringLinkToFront(link.ui);
        });
     
     renderer.rerender();
    }).mouseLeave(function(node) {
     
     colorLinks(lastHovered);
     lastHovered = null;
     
     colorLinks(node);
     renderer.rerender();
    });

    var APPROX_FACTOR = 10000;

    // pause rendere on spacebar
    var paused = false;
    $(window).keydown(function(e) {
        if (e.keyCode === 32) { // toggle on spacebar; 
            e.preventDefault();
            paused = !paused;
            if (paused) { renderer.pause(); } 
            else { renderer.resume(); } 

        }
    });

    var width = $("#g").width(),
        height= $("#g").height();

    renderer.run();
    graphics.scale(0.15, {x : width/2, y : height/2});

    // websockets part


    var linksBuffer = [];
    var wsUri = "ws://ws.blockchain.info/inv"; 
    if (document.location.protocol.indexOf("https") === 0) {
      wsUri = "wss://ws.blockchain.info/inv"; 
    }
    var output;


    function getMempool() {
        return $.getJSON('https://api.haskoin.com/btc/mempool?notx=false&limit=50000', data => {
            console.log('MEMPOOL', data)
            return data
        })
    }
    function getLastBlock() {
        return $.getJSON('https://api.haskoin.com/btc/block/best?notx=true', data => {
            console.log('BEST', data)
            return data
        })
    }
    function getLatestBlocks() {
        return $.getJSON('https://api.haskoin.com/btc/block/latest?notx=true', data => {
            console.log('BLOCKS', data)
            return data
        })
    }
    function getBlockTxs(id) {
        return $.getJSON('https://api.haskoin.com/btc/transactions/block/' + id, data => {
            console.log('BLOCKTXS '+id)
            return data
        })
    }
    async function loadTxs(txids) {
        const myTxs = [];
        var x=0;
        while(myTxs.length < 1000 && txids.length>0) {
            for (var i = 0; i < 100; i++) {
                myTxs.push(txids.pop())
            }
            console.log('loadTxs #'+x)
            await $.getJSON('https://api.haskoin.com/btc/transactions', {txids: txids.join(',')}, data => {
                //console.log('TXS', data)
                return data
            }).then(txs => onTxs(txs))
            x++;
        }
    }
    async function loadBlocks(blks) {
        for (const block of blks) {
            const txs = await getBlockTxs(block.hash)
            onTxs(txs)
            blocks++;
            blockHeight = block.height
            $('#blocks').html(blocks)
            $('#blockHeight').html(blockHeight)
        }
    }
    getLatestBlocks().then(blocks => loadBlocks(blocks))
     
     function init() { 
     	output = document.getElementById("output"); 
     	testWebSocket();
     }  
     

     var colorNodes = function(node, color) {
         if (node && node.id) {
             graph.forEachNode(function(node){
                if (color) { 
                    node.ui.color = color;
                }
            });
         }
     };

     function addNodes(link){

        if(link.t == "i"){
            var node = graph.getNode(link.from); 
            if( !node ){
                graph.addNode(link.from,{s:link.value,t:link.t,tt:link.tt,h:link.h,p:link.p, tv:link.tv});
            } else {
                // such a node already exists
                if(node.data && node.data.t && node.data.t == "o" ){
                    node.data.t = "mix";
                    node.ui.color = 16776960;
                    renderer.rerender();
                }
            }
            // tx node
            node = graph.getNode(link.to);
            if( !node ){
                graph.addNode(link.to,{h:link.h, p:link.p, tt:link.tt, tv:link.tv});
            }
        } else if(link.t == "o"){
            var node = graph.getNode(link.to); 
            if( !node){
                graph.addNode(link.to,{s:link.value,t:link.t,tt:link.tt,h:link.h,p:link.p, tv:link.tv});
            } else {
                // such a node alredy exists.  
                if(node.data && node.data.t && node.data.t == "i"){
                    node.data.t = "mix";
                    node.ui.color = 16776960;
                    renderer.rerender();
                }
            }
            // tx node
            node = graph.getNode(link.from);
            if( !node ){
                graph.addNode(link.from,{h:link.h, p:link.p, tt:link.tt, tv:link.tv});
            }
        }
     }

     function getValue(o) {
         return o.value || (o.prev_out ? o.prev_out.value : 0)
     }

     var ADDRESSES_MIX_INPUTS = {}
     var ADDRESSES_TX0_OUTPUTS = {}

     var ADDRESSES_MIX_OUTPUTS = {}
     var ADDRESSES_SPEND_INPUTS = {}

    var LINKS_UNCONFIRMED = {}

     const TXTYPE = {
         MIX: 'MIX',
         SPEND: 'SPEND',
         TX0: 'TX0'
     };

    const POOL_DENOMINATIONS = [100000,1000000,5000000,50000000]

    function toDenomination(value) {
        return Math.floor(value/APPROX_FACTOR)*APPROX_FACTOR;
    }
    function isMixInputValue(value) {
        for (const d of POOL_DENOMINATIONS) {
            if (d == toDenomination(value)) {
                return true;
            }
        }
        return false;
    }
    function isMixOutputValue(value) {
        for (const d of POOL_DENOMINATIONS) {
            if (d == value) {
                return true;
            }
        }
        return false;
    }

    function isMix(inputs,outputs,txid) {
        var mock = false;
        if (mock) return Math.random()>0.5;

        if (!inputs || !outputs || inputs.length!=5 || outputs.length!=5) return false;

        for (const i of inputs) {
            const value = getValue(i)
            if (!isMixInputValue(value)) {
                console.log('Not a mix input: '+txid, value)
                return false;
            }
        }
        for (const o of outputs) {
            const value = getValue(o)
            if (!isMixOutputValue(value)) {
                console.log('Not a mix output: '+txid, value)
                return false;
            }
        }
        return true;
    }

    function getAddress(o) {
        const addr = o.address || o.addr || (o.prev_out ? o.prev_out.addr : o.pkscript)
        /*if (!addr && !o.coinbase) {
            console.warn('addr',addr,o)
        }*/
        return addr;
    }

    function isPostmixSpend(inputs,outputs,txid) {
        if (!inputs || !outputs) return false;

        for (const o of inputs) {
            const addr = getAddress(o)
            if (ADDRESSES_MIX_OUTPUTS[addr]) {
                // found spend linked to a mix
                return 1;
            }

            const value = getValue(o)
            if (isMixOutputValue(value)) {
                // found potential spend
                return -1;
            }
        }
        return 0;
    }

    function isTx0(inputs,outputs,txid) {
        if (!inputs || !outputs || outputs.length<3) return false;

        let nonPremixs=0;
        let opReturns=0;
        let fees=0;
        for (const o of outputs) {
            const addr = getAddress(o)
            if (ADDRESSES_MIX_INPUTS[addr]) {
                // found tx0 linked to a mix
                return 1;
            }

            const value = getValue(o)
            if (value == 0) {
                opReturns++;
                if (opReturns>0) {
                    return 0;
                }
            }
            else if (value <= 2500000) {
                fees++;
            }
            if (!isMixInputValue(value)) {
                nonPremixs++;
                /*if (nonPremixs>2) {
                    return 0;
                }*/
            }
        }
        if (fees < 1 || opReturns != 1 || nonPremixs < 2) {
            return 0;
        }

        // found potential tx0
        return -1;
    }

    function confirmUnconfirmeds(txids, links) {
        if (txids) {
            for (const txid of txids) {
                const unconfirmedLinks = LINKS_UNCONFIRMED[txid]
                if (unconfirmedLinks) {
                    console.log('confirmed '+txid,unconfirmedLinks)
                    links.push(...unconfirmedLinks)
                }
            }
        }
    }

     function testWebSocket() { 
     	websocket = new WebSocket(wsUri); 
     	websocket.onopen = function(evt) { onOpen(evt) };
     	websocket.onclose = function(evt) { onClose(evt) }; 
     	websocket.onmessage = function(evt) { onMessage(evt) };
     	websocket.onerror = function(evt) { onError(evt) }; }

     	$('#since').html(since)

     	function onOpen(evt) { 
     		doSend({"op":"unconfirmed_sub"});
     	}
     	
     	function onClose(evt) {  }

        function onTxs(txs) {
            var links = []
            for (const tx of txs) {
                links.push(...onTx(tx))
            }
            //console.log('txs',links, txs)

            // flush the buffer if not empty
            if (! paused && linksBuffer.length > 0) {
                for(var i=0;i<linksBuffer.length;i++){
                    var link = linksBuffer[i];

                    addNodes(link)
                    graph.addLink(link.from,link.to, {p: link.p, h: link.h});
                }
                linksBuffer = [];
            }

            for(var i=0;i<links.length;i++){
                var link = links[i];
                if(link.value > maxNodeSize){
                    maxNodeSize = link.value;
                }

                if (! paused) {
                    addNodes(link);
                    graph.addLink(link.from,link.to, {p: link.p, h: link.h});
                } else{
                    // add links to a buffer
                    linksBuffer.push(link);
                }
            }
        }

        function onTx(tx) {
            var links = [];
            var txHash = tx.txid || tx.hash;
            allTxs++;
            $('#txHash').html(txHash)
            $('#allTxs').html(allTxs)
            // uncorfimed transactions
            var inputs = tx.inputs;
            var outputs = tx.outputs || tx.out;
            if (isMix(inputs,outputs,txHash)) {
                links = addTx(inputs, outputs, txHash, TXTYPE.MIX);

                whirlpoolTxs++;
                $('#whirlpoolTxs').html(whirlpoolTxs)
            }
            else {
                const spend = isPostmixSpend(inputs, outputs, txHash);
                if (spend == 1) {
                    console.log('found real spend: ' + txHash)
                    links = addTx(inputs, outputs, txHash, TXTYPE.SPEND, true);

                    spends++;
                    $('#spends').html(spends)
                } else if (spend == -1) {
                    console.log('found potential spend: ' + txHash)

                    addTx(inputs, outputs, txHash, TXTYPE.SPEND, false);
                } else {
                    const tx0 = isTx0(inputs, outputs, txHash)
                    if (tx0 == 1) {
                        console.log('found real tx0: '+txHash)
                        links = addTx(inputs, outputs, txHash, TXTYPE.TX0, true);

                        tx0s++;
                        $('#tx0s').html(tx0s)
                    } else if (tx0 == -1) {
                        console.log('found potential tx0: '+txHash)

                        addTx(inputs, outputs, txHash, TXTYPE.TX0, false);
                    }
                }
            }
            if (links.length>0) {
                console.log('tx: ' + txHash, links)
            }
            return links
        }

        function addTx(inputs, outputs, txHash, txType, confirmed) {
            const links = []
            var pool = (Math.floor(getValue(inputs[0])/APPROX_FACTOR)*APPROX_FACTOR/100000000)+"btc"
            var totalValue = outputs.map(o => getValue(o)).reduce((a,b)=>a+b,0);
            // generate from to
            if (inputs) {
                for (var i = 0; i < inputs.length; i++) {
                    var input = inputs[i];
                    const addr = getAddress(input);
                    const value = getValue(input);
                    links.push({
                        from: addr,
                        to: txHash,
                        value: value,
                        tv: totalValue,
                        t: "i",
                        tt: txType,
                        p: pool,
                        h: txHash
                    });
                    if (txType == TXTYPE.MIX) {
                        ADDRESSES_MIX_INPUTS[addr] = true;

                        // confirm tx0s
                        const txidsToConfirm = ADDRESSES_TX0_OUTPUTS[addr];
                        confirmUnconfirmeds(txidsToConfirm, links)
                        delete ADDRESSES_TX0_OUTPUTS[addr];
                    } else if (txType == TXTYPE.SPEND) {
                        if (!ADDRESSES_SPEND_INPUTS[addr]) {
                            ADDRESSES_SPEND_INPUTS[addr] = []
                        }
                        ADDRESSES_SPEND_INPUTS[addr].push(txHash)
                    }
                }
            }
            if (outputs) {
                for (var j = 0; j < outputs.length; j++) {
                    var output = outputs[j];
                    const addr = getAddress(output);
                    links.push({
                        from: txHash,
                        to: addr,
                        value: getValue(output),
                        tv: totalValue,
                        t: "o",
                        tt: txType,
                        p: pool,
                        h: txHash
                    });
                    if (txType == TXTYPE.MIX) {
                        ADDRESSES_MIX_OUTPUTS[addr] = true

                        // confirm spends
                        const txidsToConfirm = ADDRESSES_SPEND_INPUTS[addr];
                        confirmUnconfirmeds(txidsToConfirm, links)
                        delete ADDRESSES_SPEND_INPUTS[addr];
                    } else if (txType == TXTYPE.TX0) {
                        if (!ADDRESSES_TX0_OUTPUTS[addr]) {
                            ADDRESSES_TX0_OUTPUTS[addr] = []
                        }
                        ADDRESSES_TX0_OUTPUTS[addr].push(txHash)
                    }
                }
            }
            if (!confirmed) {
                LINKS_UNCONFIRMED[txHash] = links
            }
            return links
        }

     	function onMessage(evt) {
     		// parse message
     		var msg = JSON.parse(evt.data);
     		//console.log('onMessage',msg)
            if(msg.op == "utx"){
                onTxs([msg.x])
     		}
     		//websocket.close(); 
     	}

     	function onError(evt) { 
     		console.error('error: ',evt);
     	}

     	function doSend(message) { 
     		websocket.send(JSON.stringify(message));
     	}

     	window.addEventListener("load", init, false);  
        window.l = layout;
        window.g = graph;
        window.r = renderer;
        </script> 


</html>
