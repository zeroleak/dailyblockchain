<!DOCTYPE html>  
<html>
<head>
    <meta charset="utf-8" />
    <title>Samourai Whirlpool live</title>
	
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="js/vivagraph.js"></script>  
    <script type="text/javascript" src="js/webgl-programs.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
    <style>
    body{
        margin: 0;
        padding: 0;
        position: relative;
        background:#054050;
        color:#cbd7da;
    }
    .input-node{color:green;}
    .output-node{color:red;}
    .input-output-node{color:orange;}
    .transaction-node{color:#008ed2;}

    #log{
        position: absolute;
        left:4px;
        top:4px;
        padding:4px;
        text-align:left;
        font-size:0.8em;
    }
    #info{
        position: absolute;
        right:4px;
        top:4px;
        padding:4px;
    }
    </style>

    <link rel="shortcut icon" href="http://samouraiwallet.com/static/public/favicon/favicon.ico"/>
    <link rel="apple-touch-icon" sizes="57x57" href="http://samouraiwallet.com/static/public/favicon/apple-icon-57x57.png"/>
    <link rel="apple-touch-icon" sizes="60x60" href="http://samouraiwallet.com/static/public/favicon/apple-icon-60x60.png"/>
    <link rel="apple-touch-icon" sizes="72x72" href="http://samouraiwallet.com/static/public/favicon/apple-icon-72x72.png"/>
    <link rel="apple-touch-icon" sizes="76x76" href="http://samouraiwallet.com/static/public/favicon/apple-icon-76x76.png"/>
    <link rel="apple-touch-icon" sizes="114x114" href="http://samouraiwallet.com/static/public/favicon/apple-icon-114x114.png"/>
    <link rel="apple-touch-icon" sizes="120x120" href="http://samouraiwallet.com/static/public/favicon/apple-icon-120x120.png"/>
    <link rel="apple-touch-icon" sizes="144x144" href="http://samouraiwallet.com/static/public/favicon/apple-icon-144x144.png"/>
    <link rel="apple-touch-icon" sizes="152x152" href="http://samouraiwallet.com/static/public/favicon/apple-icon-152x152.png"/>
    <link rel="apple-touch-icon" sizes="180x180" href="http://samouraiwallet.com/static/public/favicon/apple-icon-180x180.png"/>
    <link rel="icon" type="image/png" sizes="192x192" href="http://samouraiwallet.com/static/public/favicon/android-icon-192x192.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="http://samouraiwallet.com/static/public/favicon/favicon-16x16.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="http://samouraiwallet.com/static/public/favicon/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="96x96" href="http://samouraiwallet.com/static/public/favicon/favicon-96x96.png"/>
</head>
<body>
	<div id="g" style="background:#043a48; border-bottom:12px solid #c12727; width:100%; height:800px;"></div>
    <div id="info"></div>
    <div id="log">
        Processed <span id="blocks">0</span> blocks since #<span id="blockHeight">0</span>, <span id="allTxs">0</span> txs, <span id="whirlpoolTxs">0</span> mixs.<br/>
        <small id="txHash"></small>
    </div>
    <div style="float:right">&lt;scroll&gt; to zoom<br/>&lt;space&gt; to pause</div>
    <center>
        <h1>Samourai Whirlpool live</h1>
        Visualizing Whirlpool transactions from 100 last blocks and mempool (real-time).<br/>
        <span class="input-node">Green = input</span>, <span class="output-node">Red = unspent output</span>,
        <span class="input-output-node">Yellow = spent output</span>, <span class="transaction-node">Blue = mix</span>
    </center>

    <br/><br/>
    <center><small style="color:#ccc"><a href="https://samouraiwallet.com">SamouraiWallet</a> - Visualization forked from <a href="https://dailyblockchain.github.io/" target="_blank">dailyblockchain.github.io</a></small></center>

</body>
    <script language="javascript" type="text/javascript">  
    // viva graph part 
    var graphics = Viva.Graph.View.webglGraphics();
    
    var isWebgl = graphics.isSupported();
    if (!isWebgl) {
        alert("Turn on webgl or use modern browser");
    }
    
    var graph = Viva.Graph.graph(),
    layout = Viva.Graph.Layout.forceDirected(graph, {
       springLength : 80,
       springCoeff : 0.0002,
       dragCoeff : 0.009,
       gravity : -30,
       theta : 0.7
    }), 

	minNodeSize = 1,
    maxNodeSize = 100000000;


    function log10(val) {
        return Math.log(val) / Math.LN10;
    }

    function log2(val) {
        return Math.log(val) / Math.LN2;
    }

    var scaleType = "LINEAR"; //"LOG"; // LINEAR

    var getNodeColor = function(node) {
        // here different colors for tx, input, output, mixed and txconfirmed
        if(node.data && node.data.t && node.data.t == "i"){ 
            return 0x00FF00;
        }else if(node.data && node.data.t && node.data.t == "o"){
            return 0xFF0000;
        }else if(node.data && node.data.t && node.data.t == "m"){
            return 0xFFA500;
        }
        return 0x008ED2;
    },
    
    getNodeSize = function(node){
        if(! node.data || !node.data.s){
            return 50;
        }
        var rmin = 32;
        var rmax = 96;
        

        // linear normalization to a range rmin,rmax
        if(scaleType == "LINEAR"){
            return rmin + (rmax - rmin) * ( (node.data.s - minNodeSize)/(maxNodeSize - minNodeSize) ) ;
        }else{    
            // log normalization to a range rmin,rmax
            var min = log2(minNodeSize);
            var max = log2(maxNodeSize);
            var val = log2( node.data.s );

            // linear scaling from min.max -> rmin rmax
            return rmin + (rmax - rmin) * ( (val - min)/(max - min) ) ;
        }
    },
    getNodeDetails = function(node){
        console.log('details',node);
        var label = "Mix transaction";
        var id = '';
        if(node.data && node.data.t){
            // input/output
            id += 'Address: <a href="https://oxt.me/address/' + node.id + '" target="_blank">' + node.id + '</a><br/>';
            if(node.data.t == "i"){
                // input node
                label = "Mix input";
            }else if(node.data.t == "o"){
                // output node
                label = "Unspent mix output";
            }else if(node.data.t == "mix"){
                // node which is both input and output
                label = "Remixed output";
            }

        }else{
            // transaction node
            id='';
        }
        var linkData = node.data ? node.data : node.links[0].data
        id += 'Tx: <small><a href="https://oxt.me/transaction/' + linkData.h + '" target="_blank">' + linkData.h + '</a></small><br/>';
        id += 'Pool: '+linkData.p;
        var html = "<h4>"+label+"</h4><small>"+id
        if (node.data && node.data.s) {
            html += "<br/>Value: "+(node.data.s/100000000)+" BTC";
        }
        document.getElementById("info").innerHTML = html
    };

    // need to get these 2 from yavis.reddit.min.js
    graphics.setLinkProgram(Viva.Graph.View.webglDualColorLinkProgram());
    graphics.setNodeProgram(Viva.Graph.View.webglCustomNodeProgram());

    graphics
    .node(function(node){
        if (false && node.data) {
            /*return Viva.Graph.svg('image')
                .attr('width', 24)
                .attr('height', 24)
                .link(node.data.url);*/

        } else {
            return Viva.Graph.View.webglSquare(getNodeSize(node), getNodeColor(node));
        }
     })
    .link(function(link){
         var fromColor, toColor;
         fromColor = toColor = 0x808080;
         var line = Viva.Graph.View.webglDualColorLine(fromColor, toColor);
         line.oldStart = fromColor;
         line.oldEnd = toColor;
         return line;
    });

    var renderer = Viva.Graph.View.renderer(graph,{
       layout     : layout,
       graphics   : graphics,
       container  : document.getElementById('g')
       //prerender  : 10
    });

    var blocks = 0, blockHeight='', allTxs = 0, whirlpoolTxs = 0, since=new Date().toISOString();

var events = Viva.Graph.webglInputEvents(graphics, graph),
    lastHovered = null,

    colorLinks = function(node, color) {
     if (node && node.id) {
        graph.forEachLinkedNode(node.id, function(node, link){
            if (color) { 
                link.ui.start = link.ui.end = color;
            } else {
                //link.ui.start = link.ui.oldStart; 
                //link.ui.end =link.ui.oldEnd;
                link.ui.start = link.ui.end = 0x80808040;
            } 
        });
     }
    };
                 
    events.click(function(node){
        
	    getNodeDetails(node);

        colorLinks(lastHovered);
        lastHovered = node;
     
        graph.forEachLinkedNode(node.id, function(node, link){
            link.ui.start = link.ui.end = 0xffffffff;
            graphics.bringLinkToFront(link.ui);
        });
     
     renderer.rerender();
    }).mouseLeave(function(node) {
     
     colorLinks(lastHovered);
     lastHovered = null;
     
     colorLinks(node);
     renderer.rerender();
    });

    var APPROX_FACTOR = 10000;

    // pause rendere on spacebar
    var paused = false;
    $(window).keydown(function(e) {
        if (e.keyCode === 32) { // toggle on spacebar; 
            e.preventDefault();
            paused = !paused;
            if (paused) { renderer.pause(); } 
            else { renderer.resume(); } 

        }
    });

    var width = $("#g").width(),
        height= $("#g").height();

    renderer.run();
    graphics.scale(0.15, {x : width/2, y : height/2});

    // websockets part


    var linksBuffer = [];
    var wsUri = "ws://ws.blockchain.info/inv"; 
    if (document.location.protocol.indexOf("https") === 0) {
      wsUri = "wss://ws.blockchain.info/inv"; 
    }
    var output;


    function getMempool() {
        return $.getJSON('https://api.haskoin.com/btc/mempool?notx=false&limit=50000', data => {
            console.log('MEMPOOL', data)
            return data
        })
    }
    function getLastBlock() {
        return $.getJSON('https://api.haskoin.com/btc/block/best?notx=true', data => {
            console.log('BEST', data)
            return data
        })
    }
    function getLatestBlocks() {
        return $.getJSON('https://api.haskoin.com/btc/block/latest?notx=true', data => {
            console.log('BLOCKS', data)
            return data
        })
    }
    function getBlockTxs(id) {
        return $.getJSON('https://api.haskoin.com/btc/transactions/block/' + id, data => {
            console.log('BLOCKTXS '+id, data)
            return data
        })
    }
    async function loadTxs(txids) {
        const myTxs = [];
        var x=0;
        while(myTxs.length < 1000 && txids.length>0) {
            for (var i = 0; i < 100; i++) {
                myTxs.push(txids.pop())
            }
            console.log('loadTxs #'+x)
            await $.getJSON('https://api.haskoin.com/btc/transactions', {txids: txids.join(',')}, data => {
                console.log('TXS', data)
                return data
            }).then(txs => onTxs(txs))
            x++;
        }
    }
    async function loadBlocks(blks) {
        for (const block of blks) {
            const txs = await getBlockTxs(block.hash)
            onTxs(txs)
            blocks++;
            blockHeight = block.height
            $('#blocks').html(blocks)
            $('#blockHeight').html(blockHeight)
        }
    }
    getLatestBlocks().then(blocks => loadBlocks(blocks))
     
     function init() { 
     	output = document.getElementById("output"); 
     	testWebSocket();
     }  
     

     var colorNodes = function(node, color) {
         if (node && node.id) {
             graph.forEachNode(function(node){
                if (color) { 
                    node.ui.color = color;
                }
            });
         }
     };

     function addNodes(link){
        
        if(link.t == "i"){
            var node = graph.getNode(link.from); 
            if( !node ){
                graph.addNode(link.from,{s:link.value,t:link.t,h:link.h,p:link.p});
            } else {
                // such a node already exists
                if(node.data && node.data.t && node.data.t == "o" ){
                    node.data.t = "mix";
                    node.ui.color = 16776960;
                    renderer.rerender();
                }
            }
        } else if(link.t == "o"){
            var node = graph.getNode(link.to); 
            if( ! node){
                graph.addNode(link.to,{s:link.value,t:link.t,h:link.h,p:link.p});
            } else {
                // such a node alredy exists.  
                if(node.data && node.data.t && node.data.t == "i"){
                    node.data.t = "mix";
                    node.ui.color = 16776960;
                    renderer.rerender();
                }
            }
        } 
     }

     function getValue(o) {
         return o.value || (o.prev_out ? o.prev_out.value : 0)
     }

     function testWebSocket() { 
     	websocket = new WebSocket(wsUri); 
     	websocket.onopen = function(evt) { onOpen(evt) };
     	websocket.onclose = function(evt) { onClose(evt) }; 
     	websocket.onmessage = function(evt) { onMessage(evt) };
     	websocket.onerror = function(evt) { onError(evt) }; }

     	$('#since').html(since)

     	function onOpen(evt) { 
     		doSend({"op":"unconfirmed_sub"});
     	}
     	
     	function onClose(evt) {  }

     	function findPool(inputs,outputs,txid) {
            var mock = false;
            if (mock) return Math.random()>0.5;

            if (!inputs || !outputs || inputs.length!=5 || outputs.length!=5) return false;

            const getApproxValue = i => Math.floor(getValue(i)/APPROX_FACTOR);

            var value = getApproxValue(inputs[0])
            for (const o of [...inputs,...outputs]) {
                const v = getApproxValue(o);
                if (value != v) {
                    console.log('Not a mix: '+txid, value, v)
                    return false;
                }
            }
            return value;
        }

        function onTxs(txs) {
            var links = []
            for (const tx of txs) {
                links.push(...onTx(tx))
            }
            console.log('txs',links, txs)

            // flush the buffer if not empty
            if (! paused && linksBuffer.length > 0) {
                for(var i=0;i<linksBuffer.length;i++){
                    var link = linksBuffer[i];

                    addNodes(link)
                    graph.addLink(link.from,link.to, {p: link.p, h: link.h});
                }
                linksBuffer = [];
            }

            for(var i=0;i<links.length;i++){
                var link = links[i];
                if(link.value > maxNodeSize){
                    maxNodeSize = link.value;
                }

                if (! paused) {
                    addNodes(link);
                    graph.addLink(link.from,link.to, {p: link.p, h: link.h});
                } else{
                    // add links to a buffer
                    linksBuffer.push(link);
                }
            }
        }

        function onTx(tx) {
            var links = [];
            var txHash = tx.txid || tx.hash;
            allTxs++;
            $('#txHash').html(txHash)
            $('#allTxs').html(allTxs)
            $('#whirlpoolTxs').html(whirlpoolTxs)
            // uncorfimed transactions
            var inputs = tx.inputs;
            var outputs = tx.outputs || tx.out;
            if (findPool(inputs,outputs,txHash)) {
                var pool = (Math.floor(getValue(inputs[0])/APPROX_FACTOR)*APPROX_FACTOR/100000000)+"btc"
                whirlpoolTxs++;
                // generate from to
                if (inputs) {
                    for (var i = 0; i < inputs.length; i++) {
                        var input = inputs[i];
                        links.push({
                            from: input.address || input.prev_out.addr,
                            to: txHash,
                            value: getValue(input),
                            t: "i",
                            p: pool,
                            h: txHash
                        });
                    }
                }
                if (outputs) {
                    for (var j = 0; j < outputs.length; j++) {
                        var output = outputs[j];
                        links.push({
                            from: txHash,
                            to: output.address || output.addr,
                            value: getValue(output),
                            t: "o",
                            p: pool,
                            h: txHash
                        });
                    }
                }
            }
            if (links.length>0) {
                console.log('tx: ' + txHash, links)
            }
            return links
        }

     	function onMessage(evt) {
     		// parse message
     		var msg = JSON.parse(evt.data);
     		console.log('onMessage',msg)
            if(msg.op == "utx"){
                onTxs([msg.x])
     		}
     		//websocket.close(); 
     	}

     	function onError(evt) { 
     		console.error('error: ',evt);
     	}

     	function doSend(message) { 
     		websocket.send(JSON.stringify(message));
     	}

     	window.addEventListener("load", init, false);  
        window.l = layout;
        window.g = graph;
        window.r = renderer;
     	
        $("input[name='scaleType']").change(function(){
            scaleType = this.value;
            graph.forEachNode(function(node){
                node.ui.size =  getNodeSize(node);
            })
        });
        </script> 


</html>
